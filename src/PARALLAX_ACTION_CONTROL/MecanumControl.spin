CON  '' For testing use only  _clkmode = xtal1 + pll16x  _xinfreq = 5_000_000  _ConClkFreq = ((_clkmode - xtal1) >> 6) * _xinfreq  _Ms_001   = _ConClkFreq / 1_000  '' ------------------------  ' Config  mot_Shutdown1n2 = 0  mot_1Stop = 64  mot_2Stop = 192  motCmdStopAll   = 0  motCmdForward   = 1  motCmdReverse   = 2  motCmdLeft      = 3  motCmdRight     = 4  motCmdSetMot    = 5 ' Setting Individual Motors  motCmdMcTR      = 6 ' Top/Right  motCmdMcTL      = 7 ' Top/Left  motCmdMcBL      = 8 ' Bottom/Left  motCmdMcBR      = 9 ' Bottom/Right  motCmdMcCW      = 10  ' Turning Clockwise  motCmdMcCCW     = 11  ' Turning Counter-Clockwise  motCmdMcSLeft   = 12  ' Move Side Left  motCmdMcSRight  = 13  ' Move Side RightOBJ  MD1  : "FullDuplexSerial.spin"                  '<-- Replace with UART4  MD2  : "FullDuplexSerial.spin"  SSComm    : "FDS4FC.spin"  Def       : "RxBoardDef.spin"'  DBG       : "FullDuplexSerialExt.spin"VAR  long  mainHubMS  'long  motorPins[4], motorOffset[4], motorStop[4]  long  cog, cogStack[64]DAT'PUB Init(mainMS)PUB Main | i, j, k'Main(): This function is used for testing purposes only.'It initializes two instances of a full-duplex serial object, MD1 and MD2, and then waits for 500 milliseconds.  mainHubMS := _Ms_001  MD1.Start(Def#R1S2, Def#R1S1, 0, Def#SSBaud)  MD2.Start(Def#R2S2, Def#R2S1, 0, Def#SSBaud)  Pause(500)PUB Start(mainMS, Cmd, AllDutyCycle, motOrient, motDCycle)  mainHubMS := mainMS'This function starts a new cog (processor) and loads it with the motorCore function, which controls the motors.  Stop  cog := cognew(motorCore(Cmd, AllDutyCycle, motOrient, motDCycle), @cogStack) + 1  return cogPUB Stop{{ Stop & Release Core }}  if cog    cogstop(cog~ - 1) 'stops and releases the cog used by the motor core.  returnPUB motorCore(Cmd, AllDutyCycle, motOrient, motDCycle) | i, k, j{{ Load core for motor }}  SSComm.AddPort(0, Def#R1S2, Def#R1S1, SSComm#PINNOTUSED, SSComm#PINNOTUSED, SSComm#DEFAULTTHRESHOLD, %000000, Def#SSBaud)  SSComm.AddPort(1, Def#R2S2, Def#R2S1, SSComm#PINNOTUSED, SSComm#PINNOTUSED, SSComm#DEFAULTTHRESHOLD, %000000, Def#SSBaud)  SSComm.Start  'Pause(500)  'Forward(30)  'AllMotorStop  repeat                                                'takes in cmd input and executes the corrosponding direction    case long[Cmd]      motCmdStopAll:  ' Stop All Motors        AllMotorStop      motCmdForward:  ' Forward        Forward(long[AllDutyCycle])      motCmdReverse:  ' Reverse        Reverse(long[AllDutyCycle])      motCmdLeft:     ' Left Turn        Left(long[AllDutyCycle])      motCmdRight:    ' Right Turn        Right(long[AllDutyCycle])      motCmdSetMot:   ' Setting individual motors        repeat i from 0 to 3          k := long[motOrient] & ($FF << (i*8))          j := long[motDCycle] & ($FF << (i*8))          SetMotor(i+1, k >> (i*8), j >> (i*8))      motCmdMcTR:        long[motOrient] := 1 << 24 | 1 << 16 | 1 << 8 | 1        long[motDCycle] := long[AllDutyCycle] << 24 | long[AllDutyCycle] << 16 | long[AllDutyCycle] << 8 | long[AllDutyCycle]        i := 1        k := long[motOrient] & ($FF << (i*8))        j := long[motDCycle] & ($FF << (i*8))        SetMotor(i+1, k >> (i*8), j >> (i*8))        i := 2        k := long[motOrient] & ($FF << (i*8))        j := long[motDCycle] & ($FF << (i*8))        SetMotor(i+1, k >> (i*8), j >> (i*8))      motCmdMcTL:        long[motOrient] := 1 << 24 | 1 << 16 | 1 << 8 | 1        long[motDCycle] := long[AllDutyCycle] << 24 | long[AllDutyCycle] << 16 | long[AllDutyCycle] << 8 | long[AllDutyCycle]        i := 0        k := long[motOrient] & ($FF << (i*8))        j := long[motDCycle] & ($FF << (i*8))        SetMotor(i+1, k >> (i*8), j >> (i*8))        i := 3        k := long[motOrient] & ($FF << (i*8))        j := long[motDCycle] & ($FF << (i*8))        SetMotor(i+1, k >> (i*8), j >> (i*8))      motCmdMcBR:        long[motOrient] := 0 << 24 | 0 << 16 | 0 << 8 | 0        long[motDCycle] := long[AllDutyCycle] << 24 | long[AllDutyCycle] << 16 | long[AllDutyCycle] << 8 | long[AllDutyCycle]        i := 1        k := long[motOrient] & ($FF << (i*8))        j := long[motDCycle] & ($FF << (i*8))        SetMotor(i+1, k >> (i*8), j >> (i*8))        i := 2        k := long[motOrient] & ($FF << (i*8))        j := long[motDCycle] & ($FF << (i*8))        SetMotor(i+1, k >> (i*8), j >> (i*8))      motCmdMcBL:        long[motOrient] := 0 << 24 | 0 << 16 | 0 << 8 | 0        long[motDCycle] := long[AllDutyCycle] << 24 | long[AllDutyCycle] << 16 | long[AllDutyCycle] << 8 | long[AllDutyCycle]        i := 0        k := long[motOrient] & ($FF << (i*8))        j := long[motDCycle] & ($FF << (i*8))        SetMotor(i+1, k >> (i*8), j >> (i*8))        i := 3        k := long[motOrient] & ($FF << (i*8))        j := long[motDCycle] & ($FF << (i*8))        SetMotor(i+1, k >> (i*8), j >> (i*8))      motCmdMcCW:        long[motOrient] := 1 << 24 | 0 << 16 | 1 << 8 | 0        long[motDCycle] := long[AllDutyCycle] << 24 | long[AllDutyCycle] << 16 | long[AllDutyCycle] << 8 | long[AllDutyCycle]        repeat i from 0 to 3          k := long[motOrient] & ($FF << (i*8))          j := long[motDCycle] & ($FF << (i*8))          SetMotor(i+1, k >> (i*8), j >> (i*8))      motCmdMcCCW:        long[motOrient] := 0 << 24 | 1 << 16 | 0 << 8 | 1        long[motDCycle] := long[AllDutyCycle] << 24 | long[AllDutyCycle] << 16 | long[AllDutyCycle] << 8 | long[AllDutyCycle]        repeat i from 0 to 3          k := long[motOrient] & ($FF << (i*8))          j := long[motDCycle] & ($FF << (i*8))          SetMotor(i+1, k >> (i*8), j >> (i*8))      motCmdMcSLeft:        long[motOrient] := 1 << 24 | 0 << 16 | 0 << 8 | 1        long[motDCycle] := long[AllDutyCycle] << 24 | long[AllDutyCycle] << 16 | long[AllDutyCycle] << 8 | long[AllDutyCycle]        repeat i from 0 to 3          k := long[motOrient] & ($FF << (i*8))          j := long[motDCycle] & ($FF << (i*8))          SetMotor(i+1, k >> (i*8), j >> (i*8))      motCmdMcSRight:        long[motOrient] := 0 << 24 | 1 << 16 | 1 << 8 | 0        long[motDCycle] := long[AllDutyCycle] << 24 | long[AllDutyCycle] << 16 | long[AllDutyCycle] << 8 | long[AllDutyCycle]        repeat i from 0 to 3          k := long[motOrient] & ($FF << (i*8))          j := long[motDCycle] & ($FF << (i*8))          SetMotor(i+1, k >> (i*8), j >> (i*8))PUB SetMotor(MotNum, Orientation, DutyCycle) | i, compValue'The SetMotor function takes in three parameters: MotNum specifies which of the four motors to control (1 through 4)  DutyCycle := DutyCycle <#= 100         'DutyCycle specifies the duty cycle (i.e. the percentage of the time the motor is on) as a value between 1 and 100  DutyCycle := DutyCycle #>= 1  compValue := (DutyCycle * 63)/100  case MotNum    1..2:      case Orientation          'Orientation specifies whether the motor should spin forward (1) or backward (0)        0:    ' Reverse          case MotNum            1:              'SSComm[0].Tx( 64 - compValue )              SSComm.Tx(0, 64 - compValue )            2:              'SSComm[0].Tx( 192 - compValue )              SSComm.Tx(0, 192 - compValue )        1:    ' Forward          case MotNum            1:              'SSComm[0].Tx( 64 + compValue )              SSComm.Tx(0, 64 + compValue )            2:              'SSComm[0].Tx( 192 + compValue )              SSComm.Tx(0, 192 + compValue )    3..4:      case Orientation        0:    ' Reverse          case MotNum            3:              'SSComm[1].Tx( 64 - compValue )              SSComm.Tx(1, 64 - compValue )            4:              'SSComm[1].Tx( 193 - compValue )              SSComm.Tx(1, 193 - compValue )        1:    ' Forward          case MotNum            3:              'SSComm[1].Tx( 64 + compValue )              SSComm.Tx(1, 64 + compValue )            4:              'SSComm[1].Tx( 192 + compValue )              SSComm.Tx(1, 192 + compValue )  returnPUB Forward(DutyCycle) | i, compValue                   'Moves Forward{{ value: 1 to 100 percent }}  DutyCycle := DutyCycle <#= 100  DutyCycle := DutyCycle #>= 1  compValue := (DutyCycle * 63)/100{  SSComm[0].Tx( 64 + compValue )  SSComm[0].Tx( 192 + compValue )  SSComm[1].Tx( 64 + compValue )  SSComm[1].Tx( 192 + compValue )}  SSComm.Tx(0, 64 + compValue )  SSComm.Tx(0, 192 + compValue )  SSComm.Tx(1, 64 + compValue )  SSComm.Tx(1, 192 + compValue )  returnPUB Reverse(DutyCycle) | i, compValue                   'Moves Backwards{{ value: 1 to 100 percent }}  DutyCycle := DutyCycle <#= 100  DutyCycle := DutyCycle #>= 1  compValue := (DutyCycle * 63)/100{  SSComm[0].Tx( 64 - compValue )  SSComm[0].Tx( 192 - compValue )  SSComm[1].Tx( 64 - compValue )  SSComm[1].Tx( 192 - compValue )}  SSComm.Tx(0, 64 - compValue )  SSComm.Tx(0, 192 - compValue )  SSComm.Tx(1, 64 - compValue )  SSComm.Tx(1, 192 - compValue )  returnPUB Left(DutyCycle) | i, compValue                      'Turns left{{ value: 1 to 100 percent }}  DutyCycle := DutyCycle <#= 100  DutyCycle := DutyCycle #>= 1  compValue := (DutyCycle * 63)/100{  SSComm[0].Tx( 64 + compValue )  SSComm[0].Tx( 192 - compValue )  SSComm[1].Tx( 64 + compValue )  SSComm[1].Tx( 192 - compValue )}  'SSComm.Tx(0, 64 + compValue )  SSComm.Tx(0, 192 + compValue )  'SSComm.Tx(1, 64 + compValue )  SSComm.Tx(1, 192 + compValue )  returnPUB Right(DutyCycle) | i, compValue                     'Turns Right{{ value: 1 to 100 percent }}  DutyCycle := DutyCycle <#= 100  DutyCycle := DutyCycle #>= 1  compValue := (DutyCycle * 63)/100{  SSComm[0].Tx( 64 - compValue )  SSComm[0].Tx( 192 + compValue )  SSComm[1].Tx( 64 - compValue )  SSComm[1].Tx( 192 + compValue )}  'SSComm.Tx(0, 64 - compValue )  SSComm.Tx(0, 64 + compValue )  'SSComm.Tx(1, 64 - compValue )  SSComm.Tx(1, 64 + compValue )  returnPUB AllMotorStop | i                                    'Stops all motors  repeat i from 0 to 1    'SSComm[i].Tx(0)    SSComm.Tx(i, 0)  returnPUB testMotors | i                                      'A test to see if motors are working  Pause(1000)  repeat    repeat i from mot_1Stop to 1 step 1      'SSComm[0].Tx(i)      SSComm.Tx(0, i)      Pause(100)    repeat i from 1 to mot_1Stop step 1      'SSComm[0].Tx(i)      SSComm.Tx(0, i)      Pause(100)PRI Pause(ms) | t  t := cnt - 1088                                               ' sync with system counter  repeat (ms #> 0)                                              ' delay must be > 0    waitcnt(t += mainHubMS)  returnPRI PauseMin(arg)  repeat arg    Pause(60000)  returnPUB TestSetMotor | i, j                                 'Test to see if motors are moving as intended  ' Forward  repeat j from 1 to 100    repeat i from 1 to 4      SetMotor(i, 1, j)    Pause(50)  repeat j from 100 to 1    repeat i from 1 to 4      SetMotor(i, 1, j)    Pause(50)  AllMotorStop  ' Reverse  repeat j from 1 to 100    repeat i from 1 to 4      SetMotor(i, 0, j)    Pause(50)  repeat j from 100 to 1    repeat i from 1 to 4      SetMotor(i, 0, j)    Pause(50)  AllMotorStop  returnPUB FullMotionTest | i                                  'Tests all directions implemented  ' Testing right motion  repeat i from 0 to 100 step 10    Right(i)    Pause(300)  repeat i from 100 to 0 step 10    Right(i)    Pause(300)  AllMotorStop  ' Testing left motion  repeat i from 0 to 100 step 10    Left(i)    Pause(300)  repeat i from 100 to 0 step 10    Left(i)    Pause(300)  AllMotorStop  ' Testing forward motion  repeat i from 0 to 100 step 10    Forward(i)    Pause(300)  repeat i from 100 to 0 step 10    Forward(i)    Pause(300)  AllMotorStop  ' Testing reverse motion  repeat i from 0 to 100 step 10    Reverse(i)    Pause(300)  repeat i from 100 to 0 step 10    Reverse(i)    Pause(300)  AllMotorStop  return